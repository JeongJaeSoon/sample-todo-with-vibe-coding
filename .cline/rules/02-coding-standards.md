# コーディングスタンダード

## 命名規則

- 変数名: キャメルケース (camelCase)
- 定数名: 大文字のスネークケース (UPPER_SNAKE_CASE)
- 関数名: キャメルケース (camelCase)
- コンポーネント名: パスカルケース (PascalCase)
- ファイル名: コンポーネントと同じ名前 (PascalCase)
- テストファイル: `*.test.ts` または `*.test.tsx`

## フォーマット

- インデント: スペース2つ
- セミコロン: 必須
- 文字列: シングルクォート (')
- 行の最大長: 100文字
- 複合式: 括弧 () で囲む
- trailing comma: 必須

## TypeScript

- 型定義は明示的に行う
- any型の使用は避ける
- nullよりundefinedを優先する
- オプショナルチェイニング (?) と nullish合体演算子 (??) を活用する

## React

- 関数コンポーネントを使用する
- Propsには型定義を使用する
- カスタムHooksの名前は「use」で始める
- 依存配列は必ず指定する
- 状態の更新は関数形式を使用する（前の状態に依存する場合）

## スタイリング

- BEM命名規則を使用する
- クラス名は具体的で理解しやすいものにする

## Lint

- コミット前に`pnpm lint`を実行する
- 警告も可能な限り修正する
- 型チェックが通ることを確認する
- テストが通ることを確認する

## コンポーネント設計

### Atomic Design

このプロジェクトではAtomic Designパターンを採用します :

- **Atoms**: ボタン、入力フィールドなどの基本要素
- **Molecules**: 複数のAtomsを組み合わせたもの（TodoItemなど）
- **Organisms**: 複数のMoleculesを組み合わせたもの（TodoListなど）
- **Templates**: ページのレイアウト構造
- **Pages**: 実際のコンテンツを含むページ

### 重要な設計原則

1. **コンポーネントの分離**
   - プレゼンテーショナルコンポーネント: UIのみを担当
   - コンテナコンポーネント: データと状態管理を担当

2. **Props設計**
   - 必須と任意のPropsを明確に区別
   - 適切なデフォルト値の設定
   - 明示的な型定義

3. **単一責任**
   - 各コンポーネントは1つの責任のみを持つ
   - 複雑な場合は小さなコンポーネントに分割

## 状態管理の方針

### 状態の種類と管理方法

1. **ローカル状態**
   - 単一コンポーネント内の状態
   - 管理: useState/useReducer
   - 例: フォーム入力値、UI表示状態

2. **共有状態**
   - 複数コンポーネント間で共有
   - 管理: Context API
   - 例: テーマ設定、認証情報

3. **グローバル状態**
   - アプリケーション全体で共有
   - 管理: Context API（現在）

4. **サーバー状態**
   - APIから取得したデータ
   - 管理: カスタムフック

### 重要な原則

1. **不変性の維持**
   - 状態の直接変更は避ける
   - スプレッド構文などを使用して新しいオブジェクトを作成

2. **状態の最小化**
   - 必要な状態のみを保持
   - 派生データは計算で導出

3. **状態の局所化**
   - 状態は使用場所の近くに配置
   - グローバル状態は必要な場合のみ

## エラーハンドリング

### 主要なエラーハンドリング手法

1. **React エラー境界**
   - コンポーネントツリーのエラーをキャッチ
   - フォールバックUIを表示

2. **フォームバリデーション**
   - 入力値の検証
   - ユーザーフレンドリーなエラーメッセージ

3. **非同期処理**
   - try/catch構文の使用
   - ローディング状態とエラー状態の管理

4. **グローバルエラーハンドリング**
   - 未処理のエラーをキャッチ
   - 共通のエラー表示コンポーネント

### エラーハンドリングの原則

1. **ユーザーフレンドリー**
   - 技術的詳細ではなく、理解しやすいメッセージ
   - 可能な場合は解決方法を提示

2. **適切なレベルでの処理**
   - エラーは最適な場所で処理
   - UIエラーはコンポーネントで、データエラーはサービスで

3. **状態の一貫性**
   - エラー発生時も安全な状態を維持
   - 部分的な更新を避ける
